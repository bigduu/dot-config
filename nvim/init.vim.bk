"======================================================================
" basaic Configuration
" "======================================================================
set nocompatible
set autoindent
set nowrap
set ruler
set number
set relativenumber 
set showmode
set clipboard+=unnamed
set showcmd
let mapleader=","
set scrolloff=5
set sidescroll=20
filetype on
filetype plugin on
set wildmode=list:longest

"======================================================================
" search Configuration
"======================================================================
set ignorecase
set smartcase
set hlsearch
set incsearch
"======================================================================
" fileencoding
" "======================================================================
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8,gbk

if has('autocmd')
	filetype plugin indent on
endif

" Change cursor shape between insert and normal mode in iTerm2.app
if $TERM_PROGRAM =~ "iTerm"
let &t_SI = "\<Esc>]50;CursorShape=1\x7" " Vertical bar in insert mode
let &t_EI = "\<Esc>]50;CursorShape=0\x7" " Block in normal mode

let &t_SI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=1\x7\<Esc>\\"
let &t_SR = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=2\x7\<Esc>\\"
let &t_EI = "\<Esc>Ptmux;\<Esc>\<Esc>]50;CursorShape=0\x7\<Esc>\\"
endif

if has('syntax')
	syntax enable
	syntax on
endif

"======================================================================
" 
"======================================================================
set showmatch

set matchtime=2

set display=lastline

"======================================================================
" Json format
"======================================================================
com! FormatJSON %!python -c "import json, sys, collections; print json.dumps(json.load(sys.stdin, object_pairs_hook=collections.OrderedDict), ensure_ascii=False, indent=4)"

"======================================================================
" PlugIn Configuration
"======================================================================
call plug#begin()
	Plug 'vim-airline/vim-airline'
	Plug 'vim-airline/vim-airline-themes'
	" auto pairs 	
	Plug 'jiangmiao/auto-pairs'
	" Easymotion 
	Plug 'easymotion/vim-easymotion'
	Plug 'justinmk/vim-sneak'
	" vim nerdtree
	Plug 'preservim/nerdtree'
	" tagbar
	Plug 'preservim/tagbar'
	" ctrlp
	Plug 'kien/ctrlp.vim'
	" vim go
	" Plug 'fatih/vim-go', { 'do': ':GoInstallBinaries' }
	Plug 'neoclide/coc.nvim', {'branch': 'release'}
	" git
	Plug 'tpope/vim-fugitive'
	" golab search
	Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
	Plug 'yuki-yano/fzf-preview.vim', { 'branch': 'release/rpc' }
	" github copilot
	Plug 'github/copilot.vim'
	call plug#end()

"======================================================================
" Scheme Configuration
"======================================================================
set background=dark
let g:tabline_plugin_enable = 1
let g:statusline_plugin_enable = 1

"======================================================================
" NERDTree Configuration
"======================================================================
nmap <silent> <leader>w :NERDTreeToggle<CR>
nmap <silent> <leader>v :NERDTreeFind<CR>
let g:NERDTreeDirArrowExpandable = '→'
let g:NERDTreeDirArrowCollapsible = '↓'
"======================================================================
" Tagbar Configuration
"======================================================================
nmap <silent> <leader>sp :TagbarToggle<CR>
let g:tagbar_width=25
let g:tagbar_type_go = {
    \ 'ctagstype' : 'go',
    \ 'kinds'     : [
        \ 'p:package',
        \ 'i:imports:1',
        \ 'c:constants',
        \ 'v:variables',
        \ 't:types',
        \ 'n:interfaces',
        \ 'w:fields',
        \ 'e:embedded',
        \ 'm:methods',
        \ 'r:constructor',
        \ 'f:functions'
    \ ],
    \ 'sro' : '.',
    \ 'kind2scope' : {
        \ 't' : 'ctype',
        \ 'n' : 'ntype'
    \ },
    \ 'scope2kind' : {
        \ 'ctype' : 't',
        \ 'ntype' : 'n'
    \ },
    \ 'ctagsbin'  : 'gotags',
    \ 'ctagsargs' : '-sort -silent'
\ }

"======================================================================
" short key Configuration
"======================================================================
inoremap jj <Esc>
inoremap jk <Esc>
vnoremap v <Esc>
"======================================================================
" window Configuration
"======================================================================
nnoremap <c-h> <c-w>h
nnoremap <c-l> <c-w>l
nnoremap <c-j> <c-w>j
nnoremap <c-k> <c-w>k
nnoremap <s-l> gt
nnoremap <s-h> gT
set splitright

""======================================================================
" Translation Configuration
""======================================================================
nmap <silent> <Leader>t <Plug>(coc-translator-p)
vmap <Leader>t <Plug>(coc-translator-pv)

""======================================================================
" Easymotion Configuration
""======================================================================
let g:EasyMotion_use_upper = 1
let g:EasyMotion_smartcase = 1
nmap <leader>; <Plug>(easymotion-s2)

""======================================================================
" Coc.nvim Configuration
""======================================================================
"TextEdit might fail if hidden is not set.
set hidden

" Some servers have issues with backup files, see #649.
set nobackup
set nowritebackup

" Give more space for displaying messages.
set cmdheight=2

" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
" delays and poor user experience.
set updatetime=300

"  pass messages to |ins-completion-menu|.
set shortmess+=c

" Always show the signcolumn, otherwise it would shift the text each time
" diagnostics appear/become resolved.
set signcolumn=yes

" search the project files
nnoremap <Leader>gf :CocCommand fzf-preview.ProjectFiles<CR>

" search keyword in the proejct 
nmap <leader>fp <Plug>(coc-search)

" refacto
nmap <leader>rf <Plug>(coc-refactor)
nmap <leader>re <Plugf(coc-rename)

" Apply AutoFix to problem on the current line.
nmap <leader>l  <Plug>(coc-fix-current)

" Use <c-space> to trigger completion
inoremap <silent><expr> <c-space> coc#refresh()

" GoTo
nmap <silent> gd <plug>(coc-definition)
nmap <silent> gs :CocCommand metals.goto-super-method<CR>
nnoremap <silent> gi :CocCommand fzf-preview.CocImplementations<CR>
nnoremap <silent> K :call <SID>show_documentation()<CR>
function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  elseif (coc#rpc#ready())
    call CocActionAsync('doHover')
  else
    execute '!' . &keywordprg . " " . expand('<cword>')
  endif
endfunction

" Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')

" Formatting selected code.
xmap <leader>ff  <Plug>(coc-format)
nmap <leader>ff  <Plug>(coc-format)
augroup mygroup
  autocmd!
  " Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('format')
  " Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

" Remap <C-f> and <C-b> for scroll float windows/popups.
if has('nvim-0.4.0') || has('patch-8.2.0750')
  nnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  nnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
  inoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(1)\<cr>" : "\<Right>"
  inoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? "\<c-r>=coc#float#scroll(0)\<cr>" : "\<Left>"
  vnoremap <silent><nowait><expr> <C-f> coc#float#has_scroll() ? coc#float#scroll(1) : "\<C-f>"
  vnoremap <silent><nowait><expr> <C-b> coc#float#has_scroll() ? coc#float#scroll(0) : "\<C-b>"
endif

" split if not open
function! SplitIfNotOpen(...)
    let fname = a:1
    let call = ''
    if a:0 == 2
	let fname = a:2
	let call = a:1
    endif
    let bufnum=bufnr(expand(fname))
    let winnum=bufwinnr(bufnum)
    if winnum != -1
	" Jump to existing split
	exe winnum . "wincmd w"
    else
	" Make new split as usual
	exe "vsp " . fname
    endif
    " Execute the cursor movement command
    exe call
endfunction

command! -nargs=+ CocSplitIfNotOpen :call SplitIfNotOpen(<f-args>)
